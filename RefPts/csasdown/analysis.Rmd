

```{r bbn-productivity,include=F}

# Setup for bbn...
num.knots <- length(bbn.mod$obj$env$data$area)
bbn.years <- 1994:2023
NY <- length(bbn.years)
matYear<-c(rep(bbn.years,each=num.knots))
knots<-rep(1:num.knots,NY)

# SEAMly version
bbn.prod <- data.frame(Year = bbn.years[-length(bbn.years)],
                        B = bbn.mod$report$totB[-length(bbn.mod$report$totB)],
                        R = bbn.mod$report$totR[-length(bbn.mod$report$totR)], # 
                        #R = bbn.mod$report$totR, # 
                        SSB = bbn.mod$report$totB[-length(bbn.mod$report$totB)] + bbn.mod$report$totR[-length(bbn.mod$report$totR)],
                        m = bbn.mod$report$mean_m[-length(bbn.mod$report$mean_m)],
                        g = c(bbn.mod$obj$env$data$g[-length(bbn.mod$obj$env$data$g)]),
                        gR = c(bbn.mod$obj$env$data$gR[-length(bbn.mod$obj$env$data$gR)]))
                        #g = c(bbn.mod$obj$env$data$g),
                        #gR = c(bbn.mod$obj$env$data$gR),
                        #CF = cond.dat$CF[cond.dat$year %in% bbn.years[-length(bbn.years)]])
# Make all things 2020 an NA
bbn.prod[bbn.prod$Year == 2020,-1] <- NA


# Now we can get common Recruitment data R3 assumes recruits are 3 year olds, r4 are 4 year olds etc.
bbn.prod$R3 <- c(bbn.prod$R[4:nrow(bbn.prod)],NA,NA,NA)
# Assume Scallop reach recruit size at age 3, will need to check that.
bbn.prod$RPS3 <- bbn.prod$R3/bbn.prod$SSB 


### STEP 1, how old are recruits??
# First of all what is the likely age of recruits, for Sable we have 80-90 mm recruits, our tentative von B parameters are...
# Data is coming from ageing data in 1989, found here.... Y:\Offshore\Assessment\Data\Ageing\archive\old_ageing_from_Amy_2022\SAB height at age 1989_2.pdf 
von.B <- function(L.inf,to,K,age,R.size,FR.size) 
{
  L <- L.inf*(1-exp(-K*(age-to)))
  res <- data.frame(L = L, age=age)
  min.R <- min(abs(res$L - R.size))
  min.FR <- min(abs(res$L - FR.size))
  R.age <- res$age[which(abs(res$L - R.size) == min.R)]
  FR.age <- res$age[which(abs(res$L - FR.size) == min.FR)]
  bins <- data.frame(Age = c(R.age,FR.age), size = c(R.size,FR.size),class = c("Recruits","Fully Recruited"))
  return(res <- list(res=res,bins = bins))
}

# These are similar to the Sable parameters, primarily developed to eyeball Figure 35 in Hubley 2014 (Res Doc) where Figure 35 does not align with the value we currently use that are reported in the text.
# Going with the assumption the figure with data are correct and the text is wrong.
bbn.L.inf <- 164.4
#to <- 1.337 # So this uses a 1 year offset that we no longer believe in, going to make this 0.337 to align more with what we now do...
bbn.to <- -0.2
bbn.K <- 0.2
# Now the same thing for Sable...

ages <- seq(0,15,by=0.05)
bbn.res <- von.B(bbn.L.inf,bbn.to,bbn.K,ages,R.size =as.numeric(R.size),FR.size = as.numeric(FR.size))


# So here we see that just under age 3 are recruit size and that basically goes to age 4, so using age 3 as recruit size is 
# right in the sweet spot... as per what Freya has done...
p.vb <- ggplot(res$res) + geom_line(aes(x=age,y=L),size=1.5) + scale_x_continuous(breaks = 0:max(ages), expand = c(0, 0))  + 
                          scale_y_continuous(limits = c(1,L.inf),breaks = c(seq(0,150,by=5)), expand = c(0, 0)) + 
                          xlab("Age") + ylab("Shell height (mm)") +
                          geom_segment(data = res$bins %>% collapse::fselect(class == "Recruits"), aes(x=0,y=size,xend=Age,yend=size),linetype = 'dashed',color="blue") +
                          geom_segment(data = res$bins %>% collapse::fselect(class == "Recruits"), aes(x=Age,y=1,xend=Age,yend=size),linetype = 'dashed',color="blue") +
                          geom_segment(data = res$bins %>% collapse::fselect(class == "Fully Recruited"), aes(x=0,y=size,xend=Age,yend=size),linetype = 'dashed',color="darkgreen") +
                          geom_segment(data = res$bins %>% collapse::fselect(class == "Fully Recruited"), aes(x=Age,y=1,xend=Age,yend=size),linetype = 'dashed',color="darkgreen") 

save_plot(paste0(bbn.plot.loc,"von_B.png"),p.vb,base_height = 6,base_width = 10)                                                                      



# OK, so we see recruits are probably 3-4 years old based on that von B, 
# This really does a bang up job of showing the dampened cycles of the recruitment patters, most interesting.
p.rps.ts <- ggplot(bbn.prod, aes(x=Year,y=RPS3))  + geom_point() + 
                                                    xlab("'Birth' year") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                    geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 7))+
                                                    scale_y_log10() +  
                                                    scale_x_continuous(breaks = c(seq(1980,2080,by=5)))# Definitely a signal here
save_plot(paste0(bbn.plot.loc,"RPS_ts.png"),p.rps.ts,base_height =6,base_width = 10)                                               
                       
# Density dependence, we don't see any 'good' reproductive events when above 11,500 tonnes, now these 
p.rps.ssb <- ggplot(bbn.prod,aes(y=RPS3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)),size=3) + 
                                                  xlab("Spawning Stock Biomass (tonnes)") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                  geom_smooth(method = 'gam') +
                                                  scale_y_log10() + geom_vline(xintercept = 11500,size=0.5,color='firebrick2',linetype='dashed')  + 
                                                  scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))# Definitely a signal here
save_plot(paste0(bbn.plot.loc,"RPS_vs_SSB.png"),p.rps.ssb,base_height =6,base_width = 10)                                               
                       
# It is DK's opinion that you need to look at recruitment from a 'per capita' perspective to actually understand recruitment density dependence. But you should also look at Recruits against SSB
# amd when you do that, the most parsimonous model will ALMOST always be a flat line, but worth noting that DOES MEAN there is density dependence in here, because you are getting just as
# many recruits when the population abundance is low, so a smaller SSB is able to punch out as many recruits as a high SSB, but it DOES NOT MEAN that a traditional SR model will get you anywhere useful.
p.rec.ssb <- ggplot(bbn.prod,aes(y=R3,x=SSB)) + geom_text(aes(label = substr(Year,3,4)),size=3)  +
                                                xlab("Spawning Stock Biomass (tonnes)") + ylab("Recruits (tonnes)") +
                                                geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +scale_y_log10() +
                                                geom_vline(xintercept = 11500,size=0.5,color='firebrick2',linetype='dashed')  + 
                                                scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))
save_plot(paste0(bbn.plot.loc,"Rec_vs_SSB.png"),p.rec.ssb,base_height =6,base_width = 10)                                               


# Next is there any evidence of Density dependence with growth?
# Maybe a tiny bit, we don't see really high growth at high biomass, but otherwise they look similar.
# I think arguing that growth is never 'great' above 11500 (both g and gR) is a fair takeaway.
p.g.ssb <- ggplot(bbn.prod,aes(y=g,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                             xlab("") + ylab("Growth (Fully Recruited)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 11500,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500),labels = NA))

p.gR.ssb <- ggplot(bbn.prod,aes(y=gR,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                             xlab("Spawning Stock Biomass (tonnes)") + ylab("Growth (Recruits)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 11500,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))

p.gs.ssb <-  cowplot::plot_grid(p.g.ssb,p.gR.ssb,nrow=2)

save_plot(paste0(bbn.plot.loc,"Growth(FR)_vs_SSB.png"),p.gs.ssb,base_height =12,base_width = 10)                                               

# Should also look at condition vs SSB, not sure what we'd do with that for this model, but worth knowing....
# And curiously we see condition tends to be good when SSB is above 11500 tonnes (one of those it just tends not to be low  at high SSB scenarios)
# And of course all that data is from that one period of time.
p.cf.ssb <- ggplot(bbn.prod,aes(y=CF,x=SSB)) + geom_text(aes(label = substr(Year,3,4))) +
                                               xlab("Spawning Stock Biomass (tonnes)") + ylab("Condition Factor (g\u22C5dm\u00B3)") +
                                               geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                               geom_vline(xintercept = 11500,size=0.5,color='firebrick2',linetype='dashed')  + 
                                               scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))
save_plot(paste0(bbn.plot.loc,"Condition_vs_SSB.png"),p.cf.ssb,base_height =6,base_width = 10)                                               



#So natural mortality is never 'low' when the biomass is above either 11500 or 13000 tonnes, depending on your point of view.
# I think here using 1300 makes more sense as the high m's make a lot of sense temporally.
p.m.ssb <- ggplot(bbn.prod,aes(y=m,x=SSB)) + geom_text(aes(label = substr(Year,3,4)))+ 
                                             xlab("Spawning Stock Biomass (tonnes)") + ylab("Natural Mortality (instantaneous)") +
                                             geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                             geom_vline(xintercept = 13000,size=0.5,color='firebrick2',linetype='dashed')  + 
                                             scale_x_continuous(breaks = c(seq(1000,20000,by=1500)))

save_plot(paste0(bbn.plot.loc,"M_vs_SSB.png"),p.m.ssb,base_height =6,base_width = 10)                


# A plot we won't use I dont' think, effectively there is no relationship between the growth rate and the number of spawners
p.rps.g <- ggplot(bbn.prod ,aes(y=RPS3,x=g)) + geom_text(aes(label = substr(Year,3,4))) + 
                                               xlab("Growth (Fully Recruited)") + ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                               geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                               #geom_vline(xintercept = 1.2,size=0.5,color='firebrick2',linetype='dashed') # + 
                                               scale_x_continuous(breaks = c(seq(0.8,2,by=0.1)))+ scale_y_continuous(breaks = seq(0,2,by=0.1)) 

save_plot(paste0(bbn.plot.loc,"RPS_vs_Growth.png"),p.rps.g,base_height =6,base_width = 10)                

# Condition actually makes more sense to look at than growth for the density dependence in RPS, and there is nothing there whatsoever
p.rps.cf <- ggplot(bbn.prod ,aes(y=RPS3,x=CF)) + geom_text(aes(label = substr(Year,3,4))) + 
                                                 xlab("Condition Factor (g\u22C5dm\u00B3)") +  ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9)") +
                                                 geom_smooth(method = 'gam',formula = y ~ s(x, bs = "cs", k = 3)) +
                                                 #geom_vline(xintercept = 1.2,size=0.5,color='firebrick2',linetype='dashed') # + 
                                                 scale_x_continuous(breaks = c(seq(10,20,by=0.5)))  + scale_y_continuous(breaks = seq(0,2,by=0.1)) 

save_plot(paste0(bbn.plot.loc,"RPS_vs_CF.png"),p.rps.cf,base_height =6,base_width = 10)                

# So there is the Density dependence analysis, For M and Growth using breakpoints makes the most sense, probably won't have a huge effect on anything 
# as there isn't a whole lot of change with SSB.  For recruits I think the bp analysis makes the most sense, but one could argue for a linear model log(R/S) ~ SSB, but my personal hot take is the linear model will not give you the large recruitment events which have only been observed
# when biomass is low... but not too low.

# Step 2.... Correlation
# Next thing you should consider is whether there are correlations in your productivity parameters, first look to autocorrelated time series
# Then you want to look for cross-correlations between mortality, recruitment, and growth, for example maybe growth is low in years when M is high
# This will matter to your simulations, so investigate it.
# First let's look for acf in our time series...
# Starting with recruitment we see there is a strong autocorrlation in the total number of recruits
p.rec.acf <- ggAcf(na.omit(bbn.prod$R)) + ggtitle("")+ ylab("ACF Recruits")
save_plot(paste0(bbn.plot.loc,"ACF_Rec.png"),p.rec.acf,base_height =6,base_width = 10)                

# But is this simply due to the underlying trend in R over time... no because there is no trend and it also doesn't make any difference.
rec.mod <- lm(R ~ I(Year-1993),data=bbn.prod)
summary(rec.mod)
# It is not as the correlation holds
#acf(rec.mod$residuals)

# So probably better to look at per capita recruitment and see if that is a better acf'er...
# And here we do see the 1 year correlation remains, so we probably should consider some autocorrelation in the 
# RPS if possible.
p.rps.acf <- ggAcf(na.omit(log(bbn.prod$RPS3))) + ggtitle("") + ylab("ACF log(RPS)")
save_plot(paste0(bbn.plot.loc,"ACF_RPS.png"),p.rps.acf,base_height =6,base_width = 10)                

# pacf shows us that we could approximate the RPS time series as an AR2, though interesting that lag 2 is significantly negative, I think that suggest a high frequency cycling of Recruitment
# so highly correlated with the following year, then it flips 2 years out to be negative for a couple years... interesting.
p.rps.pacf <- ggPacf(na.omit(log(bbn.prod$RPS3))) + ggtitle("") + ylab("PACF log(RPS)")
save_plot(paste0(bbn.plot.loc,"PACF_RPS.png"),p.rps.pacf,base_height =6,base_width = 10)                
# On the log scale we see there is no trend in the data, there is a weak trend on the normal scale, but going to go with the log scale
rps.mod <- lm(log(RPS3) ~ I(Year-1993),data=bbn.prod)
summary(rps.mod) # Indeed there is...
# But we see the same pattern using the residuals, just a smidge weaker, so really doesn't matter which way we go with these
# acf(rps.mod$residuals)
# pacf(rps.mod$residuals)
# rps.mod.out <- data.frame(years = 1994:2017,rps.res = rps.mod$residuals)
# ggplot(rps.mod.out,aes(x=years,y=rps.res))  + geom_text(aes(label = substr(years,3,4))) + geom_smooth(method = 'gam') + xlab("") + ylab("Recruit biomas per kg of spawners (Residual)")
# So with the recruits I think we want to set it up so that there is autocorrelation in the residuals 
# But that the mean value and variance comes from either a high or low period. Not entirely sure how to do that yet....

# Is condition or growth autocorrelated
p.cf.acf <- ggAcf(bbn.prod$CF) + ggtitle("") + ylab("ACF Condition")# No autocorrelation in Condition
save_plot(paste0(bbn.plot.loc,"ACF_CF.png"),p.cf.acf,base_height =6,base_width = 10)                

# How about growth, nope nothing.
p.g.acf <- ggAcf(bbn.prod$g) + ggtitle("") + ylab("ACF Growth (FR)")# No autocorrelation in growth of FR
p.gR.acf <- ggAcf(bbn.prod$gR) + ggtitle("") + ylab("ACF Growth (Recruits)")# No autocorrelation in growth of Rec
p.gs.acf <-  cowplot::plot_grid(p.g.acf,p.gR.acf,nrow=2)

save_plot(paste0(bbn.plot.loc,"ACF_growths.png"),p.gs.acf,base_height =12,base_width = 10)                

# Natural morality correlation? Yep, weak autocorrelation, it is somewhat similar to recruitment, borderline significant
p.m.acf <- ggAcf(bbn.prod$m) + ggtitle("") + ylab("ACF Natural Mortality") + xlab("") + scale_x_continuous(breaks = 1:14,labels=NULL) # No autocorrelation in Condition
p.m.pacf <- ggPacf(bbn.prod$m) + ggtitle("") + ylab("PACF Natural Mortality")# No autocorrelation in Condition
p.m.acfs <-  cowplot::plot_grid(p.m.acf,p.m.pacf,nrow=2)
save_plot(paste0(bbn.plot.loc,"ACF_m.png"),p.m.acfs,base_height =12,base_width = 10)                


# So check if there is a linear trend, and there is...
mod.m <- lm(m~I(Year-1993),data=bbn.prod)
summary(mod.m) # There is a significant trend in m over time, largely due to low m in the last few years, which appears to be part of the cycling we are seeing thus I'd argue the pacf and acf above are fine.
# # So do the m residuals have acf
# m.mod.out <-  data.frame(years = c(1994:2019,2021,2022),m.res = mod.m$residuals)
# # So the correlation in the residuals isn't significant, is absolutely still a signal there, but technically isn't significant.
# pacf(m.mod.out$m.res)
# ggplot(m.mod.out,aes(x=years,y=m.res))  + geom_text(aes(label = substr(years,3,4))) + geom_smooth(method = 'loess') + xlab("") + ylab("Natural Mortality (Residual)")

# I did explore some other 'offsets' but that's a big ol' rabbit hole...
# So next up lets look for evidence of correlation between your productivity parameters, specifically RPS and m
# If we offset the RPS to the year they are actually showing up, either the model is trying to kill more over everything when we have a lot of recruits, or there is a real 
# relationship there.
p.rpsoff.m <- ggplot(bbn.prod,aes(x=Year,y=RPS3_offset)) + geom_text(aes(label = substr(Year-5,3,4)))  + 
                                                           xlab("") +ylab("Recruits per Spawner (kg\u00B9\u22C5kg\u207B\u00B9) & Natural mortality (Inst)") +
                                                           geom_line(aes(y = m),color='firebrick2',size=1,linetype='dashed')
# There is clearly a correlation at a lag of 1 year
p.rps.m.ccf <- ggCcf(bbn.prod$m,bbn.prod$RPS3_offset) + ggtitle("")

p.rps.m.ccf.combo <-  cowplot::plot_grid(p.rpsoff.m,p.rps.m.ccf,nrow=2)
save_plot(paste0(bbn.plot.loc,"CCF_ts_RPS_offset_m.png"),p.rps.m.ccf.combo,base_height =12,base_width = 10)                
      
# How about m vs growth, nothing really, something at lag 2 and maybe some weak cycles.
# ccf(bbn.prod$m,bbn.prod$g)
# ccf(bbn.prod$m,bbn.prod$gR)
# 
# # OK, so that's m covered, what about growth and recruits, absolutely nothing.
# ccf(bbn.prod$RPS3,bbn.prod$g,na.action= na.omit)
# ccf(bbn.prod$RPS3,bbn.prod$gR,na.action= na.omit)


# For the harvest control rules we want to look at how explotation varies with biomass and also want to make the Kobe plot of Biomass vs Explotation
# So first we need to get the explotation rate
# Not 1000% sure this is correct at this point.  It is noteworth how different this is than the map though...
# The catch data
# So catches from June 2021-May 2022 are called 2021 and removed from the 2021 survey biomass (this is different indexing from how we used to handle this for offshore)
#
# SS model mu(t) <- C(t) / (B(t) + C(t)) because our model is B(t) <- B(t-1) - C(t) and C(2017) is June 2016-Aug 2017.
#  mu[2017] <- C[June 2016-Aug 2017]/(B[2017]+C[June 2016-Aug 2017]) 
# TLM and SEAM don't calculate mu, so we do it manually here, to be analogous...
# SEAM/TLM mu(t) <- C(t-1) / (B(t) + C(t-1)) because our model is B(t) <- B(t-1) - C(t-1) and C(2016) is now June 2016-Aug 2017.
# mu[2017] <- C[June 2016-Aug 2017]/(B[2017]+C[June 2016-Aug 2017]) 
catchy <- bbn.mod$obj$env$data$C*bbn.mod$obj$env$data$area # Get this into tonnes from catch density.
#if(mod.select == "TLM") catchy <- mod.fit$obj$env$data$C
  
pred.proc.seam$log_tot_frame$totB.LCI <- exp(pred.proc.seam$log_tot_frame$log_totB - 1.96*pred.proc.seam$log_tot_frame$se_log_totB)
pred.proc.seam$log_tot_frame$totB.UCI <- exp(pred.proc.seam$log_tot_frame$log_totB + 1.96*pred.proc.seam$log_tot_frame$se_log_totB)

# See above for explanation of how I'm doing these calculations to be consistent with the past
ann.exploit <- data.frame(year = bbn.years[-length(bbn.years)],B = exp(pred.proc.seam$log_tot_frame$log_totB)[-length(bbn.years)], Catch = colSums(catchy)[-length(bbn.years)],
                          B.LCI = pred.proc.seam$log_tot_frame$totB.LCI[-length(bbn.years)], B.UCI = pred.proc.seam$log_tot_frame$totB.UCI[-length(bbn.years)])
ann.exploit$exploit <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$exploit.UCI <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B.LCI+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$exploit.LCI <- c(NA,ann.exploit$Catch[-nrow(ann.exploit)])/(ann.exploit$B.UCI+c(NA,ann.exploit$Catch[-nrow(ann.exploit)]))
ann.exploit$FM <- 1-exp(-ann.exploit$exploit)
ann.exploit$FM.LCI <- 1-exp(-ann.exploit$exploit.LCI)
ann.exploit$FM.UCI <- 1-exp(-ann.exploit$exploit.UCI)

  
ann.exploit$delta.B <- NA
ann.exploit$delta.B.per <- NA
for(i in 2:(length(bbn.years)-1)) 
{
  ann.exploit$delta.B[i] <- ann.exploit$B[i] - ann.exploit$B[i-1]
  ann.exploit$delta.B.per[i] <- (ann.exploit$B[i] - ann.exploit$B[i-1])/ ann.exploit$B[i-1] * 100
}

ann.exploit <- ann.exploit %>% collapse::fselect(!year %in% 2020:2021)

# Exploitation + uncertainty
#windows(11,11)
exploit.plot <- ggplot(ann.exploit) + geom_line(aes(x=year,y=exploit),size=1.5) + geom_ribbon(aes(ymin=exploit.LCI,ymax=exploit.UCI,x=year),alpha=0.5,fill='blue',color='blue') +
  xlab("") + ylab("Exploitation Rate (Proportional)") + scale_x_continuous(breaks = seq(1980,2030,by=3)) + ylim(c(0,0.35))
save_plot(paste0(bbn.plot.loc,"Exploit_ts.png"),exploit.plot,base_height =12,base_width = 10)                

# Kobe plot
#windows(11,11)
kobe.plt <- ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) +  xlim(c(0,15000)) + 
                                    annotate(geom="rect",xmin=0,xmax=8000,ymin=0.1,ymax=Inf, fill = "red", alpha=0.5)+
                                    annotate(geom="rect",xmin=8000,xmax=Inf,ymin=0,ymax=0.1, fill="green", alpha = 0.5) +
                                    annotate(geom="rect",xmin=0,xmax=8000,ymin=0,ymax=0.1, fill="gold1", alpha = 0.6) +
                                    annotate(geom="rect",xmin=8000,xmax=Inf,ymin=0.1,ymax=Inf, fill="gold1", alpha = 0.6) +
                                    geom_path(aes(y= exploit, x= B )) + 
                                    xlab("Biomass (Tonnes)") + ylab("Exploitation Rate (Proportional)") +
                                    geom_hline(yintercept = 0.1,linetype='dashed') + geom_vline(xintercept = 8000,linetype='dashed')

save_plot(paste0(bbn.plot.loc,"Kobe_plot.png"),kobe.plt,base_height =12,base_width = 10)                

# Same this with LRP and USR and FMSY
# The phase plot
#windows(11,11)
phase.plt <- ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) +  xlim(c(0,15000)) + 
                                    annotate(geom="rect",xmin=-Inf,xmax=2400,ymin=-Inf,ymax=Inf, fill = "red", alpha=0.5)+
                                    annotate(geom="rect",xmin=2400,xmax=4800,ymin=-Inf,ymax=Inf, fill="gold1", alpha = 0.5) +
                                    annotate(geom="rect",xmin=4800,xmax=Inf,ymin=-Inf,ymax=Inf, fill="green", alpha = 0.6) +                                  
                                    geom_path(aes(y= exploit, x= B )) +
                                    geom_hline(yintercept = 0.1,linetype='dashed') + geom_vline(xintercept = c(2400,4800),linetype='dashed') +
                                    xlab("Biomass (Tonnes)") + ylab("Exploitation Rate (Proportional)") 
save_plot(paste0(bbn.plot.loc,"Phase_plot.png"),phase.plt,base_height =12,base_width = 10)                
    
# Now that explotation vs Biomass figure...
#windows(11,11)

ggplot(ann.exploit,aes(y=delta.B,x=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='lm') +
                                          geom_hline(yintercept = 0,linetype='dashed')
                                    
   # Now that explotation vs Biomass figure... The JEM plot (Jessica's Empirical Method)....
#windows(11,11)
jem.plt <- ggplot(ann.exploit,aes(y=delta.B.per,x=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='lm',color=u.colors[2],fill=u.colors[2],alpha=0.2) +
                                                              geom_hline(yintercept = 0,linetype='dashed')   +  
                                                              xlab("Exploitation Rate (Proportional)") + ylab("Biomass Change (%)")                             
save_plot(paste0(bbn.plot.loc,"JEM_plot.png"),jem.plt,base_height =6,base_width = 10)                

                            

# Again the explotation rate against biomass but without any bells and whistles, just looking for patterns...
# And there are no real strong patterns,mu might be slightly lower at abundances above 5000...
ggplot(ann.exploit,aes(x=B,y=exploit)) + geom_text(aes(label=year)) + geom_smooth(method='gam')
# So here we can use this infor to explore potential HCR's based on what the fishery has done in the past 
B.exp <- mean(ann.exploit$exploit,na.rm=T)
B.exp.2010s <- mean(ann.exploit$exploit[ann.exploit$year %in% 2011:2019],na.rm=T)
low.B.exp <- mean(ann.exploit$exploit[ann.exploit$B < 5000])
hi.B.exp <- mean(ann.exploit$exploit[ann.exploit$B >= 5000],na.rm=T)
low.B.exp <- sd(ann.exploit$exploit[ann.exploit$B < 5000])
hi.B.exp <- sd(ann.exploit$exploit[ann.exploit$B >= 5000],na.rm=T)


# So all told what's the story
# RPS is high at low biomass, but not necessarily a linear relationship, I see this more as a story of low recruitment at high biomass with highly variable recruitment at low biomass
# There is also correlation in the RPS time series and potential that we could build in 'bonanza's' in which per-capita recruitment is high
# For natural mortality we see that m tends to be higher more frequently at high SSB than at low SSB. There is also some correlation in m with periods of higher than expect and lower than expect M.
# There's no evidence of anything particularly interesting in the growth data, no density dependence and no correlation.
# There is some correlation between m and recruitment, when recruit residuals are high so are the m residuals.  But that
# seems to be driven entirely by that 95-97 period so I don't think in a normal period there is anything interesting going on.

```



```{r productivity-simulations,include=F}

# This simulation:
# Has recruitment fixed at the median
# Estimates growth from a normal distribution based on the mean and sd of the growth time series observed in the past
# Samples the natural mortality estimate from the observed natural mortality 
# In the first year it takes the last biomass estimate and multiplies that by the exploitation rate to get a catch
# Then that value is grown/killed according to our DD model, note there is no process error in this formulation
# That formulation is below


# So the breakpoints are looking good, the linear models seem to be too 'safe', you don't get a big recruitment event ever with them
# a steady supply of recruits when maybe we shouldn't... need to look into that next.
# NOTE: I turned the process error in our model to 0, it causes big variability with no real rationale, which I don't think it great for projections.
# Notice that the population tends to 'take off' immediately in all simulations, I believe that is because average recruitment during typical SSB years
# is higher than it was from around 2012-2015, 2016 and 2017 year classes (so recruits in 2021-2022) were better recruitment years and thus we see a bit of recovery in biomass 
# in 2022 (also why the 2023 projections are quite good in the models)

# note the correlations as implemented at the moment can lead to negative recruitment, I'll need to fix that, as of June 2023 avoid using.
# RUNME
#g.strat <- data.frame(type = "cor",strat = 'dist', bp = 9000,mn.mx = 1, sd.mx = 0.05,ar1=0,ar2=0) # The g correlation method seems to get g a bit too  high.
g.strat <- data.frame(type = "sv",set.value = 1,strat = 'dist', mn.mx = 1, sd.mx = 0.05)
#g.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = 1, sd.mx = 0.05)
r.strat <- data.frame(type = "bp",strat = 'dist', bp = 1.15e4,mn.mx = 0.1*signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=3,
                              ar1=signif(p.rps.pacf$data$Freq[1],digits=2),ar2=signif(p.rps.pacf$data$Freq[2],digits=2),rps.m.cor = 0.75,rps.m.lag = 1) # Note lag is 1
#r.strat <- data.frame(type = "bp",strat = 'dist', bp = 13500,mn.mx = signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5,
#                       ar1=0,ar2=0,rps.m.cor = 0,rps.m.lag = 0)
#r.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5)
m.strat <- data.frame(type = "bp",strat = 'dist', bp = 1.15e4,mn.mx = 2*signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1, ar1=signif(p.m.pacf$data$Freq[1],digits=2),ar2=0) #
#m.strat <- data.frame(type = "bp",strat = 'dist', bp = 10000,mn.mx = signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1)
#m.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1)
mod = "SEAM"
plot_url = "D:/Framework/SFA_25_26_2024/RefPts/Figures/BBn/R_75_FR_90/"
res_url = "D:/Framework/SFA_25_26_2024/RefPts/Results/BBn/R_75_FR_90/"

Res <- proj.mod(n_sim=500,n_y = 200,model=mod,plot_url = plot_url, run = 'no_model_error', res_url = res_url,save.results = T, exp.scenario=seq(0,0.24,0.01), mod.run = bbn.select,
                #base.yrs = 2009:2022,
                g.mod =   list(type = g.strat$type,set.value = g.strat$set.value,bp.strategy = g.strat$strat,bp= g.strat$bp, 
                               mn.at.max = g.strat$mn.mx,sd.at.max = g.strat$sd.mx),
                               #ar1=g.strat$ar1,ar2=g.strat$ar2),
                 rec.mod = list(type = r.strat$type,bp.strategy = r.strat$strat,bp= r.strat$bp, 
                                mn.at.max = r.strat$mn.mx,sd.at.max = r.strat$sd.mx,rec.age = r.strat$rec.age,rps.m.cor = r.strat$rps.m.cor,rps.m.lag = r.strat$rps.m.lag,
                                ar1=r.strat$ar1,ar2=r.strat$ar2),
                 m.mod =   list(type = m.strat$type,bp.strategy = m.strat$strat,bp= m.strat$bp, mn.at.max = m.strat$mn.mx,sd.at.max = m.strat$sd.mx,
                                ar1=m.strat$ar1,ar2=m.strat$ar2))
Exp.res <- Res$Exp.res
# End RUNME
# Here are our reference point options
# Exp.res <- readRDS("D:/Framework/SFA_25_26_2024/RefPts/Results/BBn/R_75_FR_90/SEAM_1994_2022_vary_m_m0_0.2_qR_0.33_20_knots_g_original_vary_q=TRUE/RPs/SEAM_g_sv__1_dist_1_0.05_r_bp_dist_11500__0.00041_0.23_m_bp_dist_11500__0.184_0.1.Rds")


RPs <- Exp.res %>% collapse::fselect(year >= 175) %>% collapse::fgroup_by(F.scenario) %>% collapse::fsummarise(med.B = median(B,na.rm=T),
                                                                                                       med.C = median(Catch,na.rm=T))  


  
C.at.msy <- max(RPs$med.C)
RR <- RPs$F.scenario[RPs$med.C == C.at.msy] # Nobody would argue with 9% either...
B.msy <- RPs$med.B[RPs$med.C == C.at.msy]
B0 <- RPs$med.B[RPs$F.scenario==0]
# So our LRP options
LRP.B0 <- 0.2 * B0
LRP.3.BMSY <- 0.3 * B.msy
LRP.4.BMSY <- 0.4 * B.msy
# USR and TRP 
USR.B0 <- 0.4 * B0
USR.BMSY <- 0.8 * B.msy
TRP.B.msy <- B.msy
TRP.B0 <- 0.8 * B0

# How long does it take to 'rebuild'

rec.years <- sort(unique(Exp.res$year))
F.scenario <- sort(unique(Exp.res$F.scenario))

time.grid <- expand.grid(scenario = F.scenario,years = rec.years)
time.to <- data.frame(time.grid,Biomass = NA, T.msy = F,T.usr = F, T.lrp=F,T.trp = F)
for(i in rec.years)
{
B.now <- Exp.res %>% collapse::fselect(year %in% i) %>% collapse::fgroup_by(F.scenario) %>% collapse::fsummarise(med.B = median(B,na.rm=T))
time.to$Biomass[time.to$years == i] <- B.now$med.B
# This feels way clunky...
if(any(B.now$med.B >= B.msy)) 
{
  trues <- which(B.now$med.B >= B.msy)
  tmp <- time.to$T.msy[time.to$years == i]
  tmp[trues] <- T
  time.to$T.msy[time.to$years == i] <- tmp
}
if(any(B.now$med.B >= USR.BMSY))
{
   trues <- which(B.now$med.B >= USR.BMSY)
  tmp <- time.to$T.usr[time.to$years == i]
  tmp[trues] <- T
  time.to$T.usr[time.to$years == i] <- tmp
}
if(any(B.now$med.B >= LRP.B0))
{
  trues <- which(B.now$med.B >= LRP.B0)
  tmp <- time.to$T.lrp[time.to$years == i]
  tmp[trues] <- T
  time.to$T.lrp[time.to$years == i] <- tmp
}
if(any(B.now$med.B >= TRP.B0))
{
  trues <- which(B.now$med.B >= TRP.B0)
  tmp <- time.to$T.trp[time.to$years == i]
  tmp[trues] <- T
  time.to$T.trp[time.to$years == i] <- tmp
}
}


res.T.msy <- time.to %>% collapse::fgroup_by(scenario) %>% collapse::fselect(T.msy == T) %>% collapse::fselect(scenario,years,Biomass,T.msy)
res.T.usr <- time.to %>% collapse::fgroup_by(scenario) %>% collapse::fselect(T.usr == T) %>% collapse::fselect(scenario,years,Biomass,T.usr)
res.T.lrp <- time.to %>% collapse::fgroup_by(scenario) %>% collapse::fselect(T.lrp == F) %>% collapse::fselect(scenario,years,Biomass,T.lrp)
res.T.trp <- time.to %>% collapse::fgroup_by(scenario) %>% collapse::fselect(T.trp == T) %>% collapse::fselect(scenario,years,Biomass,T.trp)
# So now summarize these...

T.msy <- res.T.msy %>% collapse::fgroup_by(scenario) %>% collapse::fsummarise(T.msy = min(years))
T.usr <- res.T.usr %>% collapse::fgroup_by(scenario) %>% collapse::fsummarise(T.usr = min(years))
T.lrp <- res.T.lrp %>% collapse::fgroup_by(scenario) %>% collapse::fsummarise(T.lrp = min(years)) # Hmm...
T.trp <- res.T.trp %>% collapse::fgroup_by(scenario) %>% collapse::fsummarise(T.trp = min(years)) # This tells me that TRP is really unachievable



```

```{r hcr-sims,include =F}

hcr.strat <-data.frame(TRP = round(TRP.B0),TRP.exp = 0.1,
                       USR = round(USR.B0), USR.exp = 0.04, 
                       LRP = round(LRP.B0), LRP.exp = 0,exp.sd = 0.25)
#g.strat <- data.frame(type = "cor",strat = 'dist', bp = 9000,mn.mx = 1, sd.mx = 0.05,ar1=0,ar2=0) # The g correlation method seems to get g a bit too  high.
g.strat <- data.frame(type = "sv",set.value = 1,strat = 'dist', mn.mx = 1, sd.mx = 0.05)
#g.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = 1, sd.mx = 0.05)
r.strat <- data.frame(type = "bp",strat = 'dist', bp = 1.15e4,mn.mx = 0.1*signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=3,
                              ar1=signif(p.rps.pacf$data$Freq[1],digits=2),ar2=signif(p.rps.pacf$data$Freq[2],digits=2),rps.m.cor = 0.75,rps.m.lag = 1) # Note lag is 1
#r.strat <- data.frame(type = "bp",strat = 'dist', bp = 13500,mn.mx = signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5,
#                       ar1=0,ar2=0,rps.m.cor = 0,rps.m.lag = 0)
#r.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(min(bbn.prod$RPS3,na.rm=T),digits=2), sd.mx = 0.2,rec.age=5)
m.strat <- data.frame(type = "bp",strat = 'dist', bp = 1.15e4,mn.mx = 2*signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1, ar1=signif(p.m.pacf$data$Freq[1],digits=2),ar2=-0) #
#m.strat <- data.frame(type = "bp",strat = 'dist', bp = 10000,mn.mx = signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1)
#m.strat <- data.frame(type = "lm",strat = "Linear", bp = "Model",mn.mx = signif(max(bbn.prod$m,na.rm=T),digits=2), sd.mx = 0.1)
mod = "SEAM"
plot_url = "D:/Framework/SFA_25_26_2024/RefPts/Figures/BBn/R_75_FR_90/"
res_url = "D:/Framework/SFA_25_26_2024/RefPts/Results/BBn/R_75_FR_90/"


# An HCR model
hcr <- proj.mod(n_sim=500,n_y = 200,model=mod,plot_url = plot_url, run = 'no_model_error', res_url = res_url,save.results = T,mod.run = bbn.select,
                 g.mod =   list(type = g.strat$type,set.value = g.strat$set.value,bp.strategy = g.strat$strat,bp= g.strat$bp, mn.at.max = g.strat$mn.mx,
                                sd.at.max = g.strat$sd.mx,ar1=g.strat$ar1,ar2=g.strat$ar2),
                 rec.mod = list(type = r.strat$type,bp.strategy = r.strat$strat,bp= r.strat$bp, mn.at.max = r.strat$mn.mx,sd.at.max = r.strat$sd.mx,
                                rec.age = r.strat$rec.age,ar1=r.strat$ar1,ar2=r.strat$ar2,rps.m.cor = r.strat$rps.m.cor,rps.m.lag = r.strat$rps.m.lag),
                 m.mod =   list(type = m.strat$type,bp.strategy = m.strat$strat,bp= m.strat$bp, mn.at.max = m.strat$mn.mx,
                                sd.at.max = m.strat$sd.mx,ar1=m.strat$ar1,ar2=m.strat$ar2),
                 HCR.sim = list(TRP = hcr.strat$TRP,TRP.exp = hcr.strat$TRP.exp, USR = hcr.strat$USR, USR.exp = hcr.strat$USR.exp,
                                    LRP = hcr.strat$LRP, LRP.exp = hcr.strat$LRP.exp,exp.sd = hcr.strat$exp.sd))

summary(hcr$m)
summary(bbn.prod$m)
summary(hcr$g)
summary(bbn.prod$g)
summary(hcr$Rec)
summary(hcr$B[,,1][200,])
summary(hcr$rps)
summary(bbn.prod$RPS3)
plot(hcr$rps[,4,1])
ccf(hcr$mort[,3,1],hcr$Rec[,3,1]) #m rps correlation

```


